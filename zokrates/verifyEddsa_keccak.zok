import "hashes/keccak/256bit" as hash
import "ecc/edwardsScalarMult" as scalarMult
import "ecc/edwardsAdd" as add
import "ecc/edwardsOnCurve" as onCurve
import "ecc/edwardsOrderCheck" as orderCheck
import "utils/pack/bool/nonStrictUnpack256" as unpack256bool
from "ecc/babyjubjubParams" import BabyJubJubParams
import "utils/casts/u32_8_to_bool_256"
import "utils/pack/u32/nonStrictUnpack256" as unpack256u

import "./u64_array_to_bool_array" as u64_array_to_bool_array
import "./u32_array_to_u64_array" as u32_array_to_u64_array

/// Verifies an EdDSA Signature.
///
/// Checks the correctness of a given EdDSA Signature (R,S) for the provided
/// public key A and message M.
///
/// For more information see:
/// https://en.wikipedia.org/wiki/EdDSA
/// https://eprint.iacr.org/2015/677.pdf
///
/// Arguments:
///    R: Curve point. Hidden version of the per-message nonce.
///    S: Field element. Signature to be verified.
///    A: Curve point. Public part of the key used to create S.
///    M: Field element.The message used to create S.
///    context: Curve parameters used to create S.
///
/// Returns:
///     Return true for S being a valid EdDSA Signature, false otherwise.
def main(private field[2] R, private field S, field[2] A, u64[4] M, BabyJubJubParams context) -> bool:

    field[2] G = [context.Gu, context.Gv]

    // Check if R is on curve and if it is not in a small subgroup. A is public input and can be checked offline
    assert(onCurve(R, context)) // throws if R is not on curve
    assert(orderCheck(R, context))

    u64[8] Rx = u32_array_to_u64_array(unpack256u(R[0]))
    u64[8] Ax = u32_array_to_u64_array(unpack256u(A[0]))
    bool[256] hRAM = u64_array_to_bool_array(hash([...Rx, ...Ax, ...M]))

    bool[256] sBits = unpack256bool(S)
    field[2] lhs = scalarMult(sBits, G, context)

    field[2] AhRAM = scalarMult(hRAM, A, context)
    field[2] rhs = add(R, AhRAM, context)

    bool out = rhs[0] == lhs[0] && rhs[1] == lhs[1]

    return out
